#!/usr/bin/env python3

from app.config import Config
import app.board_parser as board_parser
import app.pretty_print as pp
import app.message as message
import app.io as io
import app.board as board
import app.logging_config
import random
import threading
import time

# our first move, a tuple of tuples (from, to)
FIRST_MOVE = ((2,1),(3,2))

# next best move
best_move = None

# weight of the best move
best_move_weight = 0

# Should the thread keep going
computing = True

# Time required for doing other stuff not related to
# actually computing the next best move
ADJUST = .2

# the actual game_board
game_board = ()

forfeit = False

def next_best_move():
    global best_move
    global best_move_weight
    global game_board
    global computing
    global forfeit

    computing = True
    all_moves = game_board.iterate_all_moves(board.Owner.PLAYER)
    best_move = next(all_moves)
    best_move_weight = random.randint(0, 100)

    while computing:
        try:
            move = next(all_moves)
        except StopIteration:
            forfeit = True
            return

        weight = random.randint(0, 100)
        if weight > best_move_weight:
            best_move = move
            best_move_weight = weight

def main():

    global game_board
    global computing

    # Initial configuration
    config = Config()
    init_board = board_parser.parse_board()

    # Initial Message (i.e initial setup)
    init_msg = message.InitMessage(init_board)

    io.send(init_msg)

    game_board = init_board

    # If we are going first, print the first move
    if config.turn == 1:
        mov_msg = message.MoveMessage(FIRST_MOVE[0], FIRST_MOVE[1])
        game_board.move_piece(FIRST_MOVE[0], FIRST_MOVE[1])
        io.send(mov_msg)

    # Add the opponent's pieces to the board
    game_board = game_board.initialize_opponent_pieces()

    while True:
        msg = io.receive()
        if isinstance(msg, message.MoveMessage):
            game_board = game_board.update(msg)
            game_board.dump_debug_board()

            # Pretty print the board (for debugging)
            pp.draw_message(msg)
            pp.draw_board(game_board)

            if msg.player == config.turn:
                continue
            compute_thread = threading.Thread(target=next_best_move)
            compute_thread.start()
            compute_thread.join((config.time / 1000) - ADJUST)
            computing = False
            if(forfeit):
                fmsg = ForfeitMessage()
                io.send(fmsg)
                exit(10)
            mov_msg = message.MoveMessage(best_move[0], best_move[1])
            io.send(mov_msg)
        elif isinstance(msg, message.FlagMessage):
            #game_board.set_flag(msg.pos)
            continue
        elif isinstance(msg, message.WinningMessage):
            break
        elif isinstance(msg, message.ErrorMessage):
            exit(-1)

    return 0

if __name__ == "__main__":
        main()
